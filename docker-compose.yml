version: '3.8'

services:
  # Microservicio de Scraping
  scraper:
    build:
      context: ./scraper
      dockerfile: Dockerfile
    container_name: serpy-scraper
    ports:
      - "8501:8501"
    environment:
      - STREAMLIT_SECRETS_TOML=${STREAMLIT_SECRETS_TOML}
      # URL del microservicio de imágenes (para comunicación interna)
      - IMAGES_SERVICE_URL=http://images:8502
    networks:
      - serpy-network
    restart: unless-stopped

  # Microservicio de Imágenes (cuando esté implementado)
  # images:
  #   build:
  #     context: ./images
  #     dockerfile: Dockerfile
  #   container_name: serpy-images
  #   ports:
  #     - "8502:8502"
  #   environment:
  #     # El servicio de imágenes puede necesitar acceder al scraper
  #     - SCRAPER_SERVICE_URL=http://scraper:8501
  #   networks:
  #     - serpy-network
  #   restart: unless-stopped

networks:
  serpy-network:
    driver: bridge

# ============================================
# CÓMO SE CONECTAN LOS MICROSERVICIOS:
# ============================================
# 
# 1. RED INTERNA (serpy-network):
#    - Todos los servicios están en la misma red Docker
#    - Pueden comunicarse usando el nombre del servicio como hostname
#    - Ejemplo: http://images:8502 o http://scraper:8501
#
# 2. VARIABLES DE ENTORNO:
#    - Cada servicio recibe las URLs de otros servicios
#    - En producción (EasyPanel), configuras estas variables manualmente
#
# 3. COMUNICACIÓN:
#    - REST API: Los servicios exponen endpoints HTTP
#    - Ejemplo desde scraper a images:
#      response = requests.post('http://images:8502/process', files={'image': image_data})
#
# 4. EN EASYPANEL:
#    - Cada app tiene su propia URL interna
#    - Configuras las URLs como variables de entorno
#    - Ejemplo: IMAGES_SERVICE_URL=http://serpy-images.internal:8502
